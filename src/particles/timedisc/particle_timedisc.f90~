!=================================================================================================================================
! Copyright (c) 2010-2016  Prof. Claus-Dieter Munz 
! This file is part of FLEXI, a high-order accurate framework for numerically solving PDEs with discontinuous Galerkin methods.
! For more information see https://www.flexi-project.org and https://nrg.iag.uni-stuttgart.de/
!
! FLEXI is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License 
! as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
!
! FLEXI is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty
! of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License v3.0 for more details.
!
! You should have received a copy of the GNU General Public License along with FLEXI. If not, see <http://www.gnu.org/licenses/>.
!=================================================================================================================================
#include "flexi.h"

!==================================================================================================================================
!> Module for the GTS Temporal discretization
!==================================================================================================================================
MODULE MOD_Particle_TimeDisc
!===================================================================================================================================
! Module for the GTS Temporal discretization  
!===================================================================================================================================
! MODULES
! IMPLICIT VARIABLE HANDLING
IMPLICIT NONE
PRIVATE
!-----------------------------------------------------------------------------------------------------------------------------------
INTERFACE Particle_InitTimeDisc
  MODULE PROCEDURE Particle_InitTimeDisc
END INTERFACE

INTERFACE Particle_TimeDisc
  MODULE PROCEDURE Particle_TimeDisc
END INTERFACE

INTERFACE Particle_FinalizeTimeDisc
  MODULE PROCEDURE Particle_FinalizeTimeDisc
END INTERFACE

!===================================================================================================================================

CONTAINS

SUBROUTINE Particle_InitTimeDisc()
!===================================================================================================================================
! Get information for end time and max time steps from ini file
!===================================================================================================================================
! MODULES
USE MOD_PreProc
USE MOD_Globals
USE MOD_TimeDisc_Vars
USE MOD_ReadInTools         ,ONLY:GETREAL,GETINT,GETSTR
USE MOD_StringTools         ,ONLY:LowCase,StripSpaces
USE MOD_Overintegration_Vars,ONLY:NUnder
USE MOD_Filter_Vars         ,ONLY:NFilter,FilterType
USE MOD_Mesh_Vars           ,ONLY:nElems
USE MOD_IO_HDF5             ,ONLY:AddToElemData,ElementOut
USE MOD_Particle_Vars
IMPLICIT NONE
!----------------------------------------------------------------------------------------------------------------------------------
! INPUT/OUTPUT VARIABLES
!----------------------------------------------------------------------------------------------------------------------------------
! LOCAL VARIABLES
!----------------------------------------------------------------------------------------------------------------------------------

! compute ratio of dt for particle surface flux emission (example a). Additionally, the ratio of RK_inflow(iStage)/RK_c(iStage) 
! gives the ! maximum distance, the Surface Flux particles can during the initial implicit step (example b).
! example a)
!   particle number for stage 4: dt*RK_inflow(4) 
! or: generate all particles for dt, but only particles with random number R < RK_c(iStage) participate in current stage.
! This results in dt*RK_inflow(iStage) particles in the current stage, hence, we can decide if we generate all particles or
! only the particles per stage. Currently, all particles are generated prior to the RK stages.
! example b)
! ESDIRKO4 from kennedy and carpenter without an acting force. Assume again stage 4. The initial particles during stage 2 are 
! moved in stage 3 without tracking (because it could be dropped out of the domain and the negative increment of the time level. 
! The new particles in this  stage could travel a distance up to RK_c(4)=SUM(ESDIRK_a(4,:)). Now, the new particles are pushed 
! further into the domain than the particles of the second stage has moved. This would create a non-uniform particle distribution.
! this is prevented by reducing their maximum emission/initial distance by RK_inflow(4)/RK_c(4).
! Note: A small overlap is possible, but this is required. See the charts in the docu folder.
RK_inflow(2)=RK_C(2)
rTmp=RK_c(2)
DO iCounter=3,nRKStages
  RK_inflow(iCounter)=MAX(RK_c(iCounter)-MAX(RK_c(iCounter-1),rTmp),0.)
  rTmp=MAX(rTmp,RK_c(iCounter))
END DO ! iCounter=2,nRKStages-1

! init
IF(DoImportIMDFile) CALL WriteIMDStateToHDF5(time) ! write IMD particles to state file (and TTM if it exists)
IF(DoWriteStateToHDF5)THEN 
!    #if (PP_TimeDiscMethod!=1) || (PP_TimeDiscMethod!=2) || (PP_TimeDiscMethod!=6)
      CALL CountPartsPerElem()
!    #endif
    CALL WriteStateToHDF5(TRIM(MeshFile),time,tFuture)
END IF

! if measurement of particle tracking time
IF(MeasureTrackTime)THEN
  nTracks=0
  tTracking=0
  tLocalization=0
END IF

#if defined(MPI)
IF ((TRIM(DepositionType).EQ."shape_function")             &
.OR.(TRIM(DepositionType).EQ."shape_function_1d")          &
.OR.(TRIM(DepositionType).EQ."shape_function_spherical")   &
.OR.(TRIM(DepositionType).EQ."shape_function_simple")      &
.OR.(TRIM(DepositionType).EQ."shape_function_cylindrical"))THEN
  ! open receive buffer for number of particles
  CALL IRecvNbofParticles()
  ! send number of particles
  CALL SendNbOfParticles()
  ! finish communication of number of particles and send particles
  CALL MPIParticleSend()
  ! finish communication
  CALL MPIParticleRecv()
END IF
#endif /*MPI PARTICLES*/

END SUBROUTINE Particle_InitTimeDisc

!===================================================================================================================================
! GTS Temporal discretization 
!===================================================================================================================================
SUBROUTINE Particle_TimeDisc()
! MODULES
USE MOD_Globals
USE MOD_PreProc
USE MOD_TimeDisc_Vars       ,ONLY: TEnd,t,dt,tAnalyze,ViscousTimeStep,maxIter,Timestep,nRKStages,nCalcTimeStepMax,CurrentStage
USE MOD_Analyze_Vars        ,ONLY: Analyze_dt,WriteData_dt,tWriteData,nWriteData
USE MOD_AnalyzeEquation_Vars,ONLY: doCalcTimeAverage
USE MOD_Analyze             ,ONLY: Analyze
USE MOD_TestCase            ,ONLY: AnalyzeTestCase,CalcForcing
USE MOD_TestCase_Vars       ,ONLY: nAnalyzeTestCase,doTCSource
USE MOD_TimeAverage         ,ONLY: CalcTimeAverage
USE MOD_Restart_Vars        ,ONLY: DoRestart,RestartTime
USE MOD_CalcTimeStep        ,ONLY: CalcTimeStep
USE MOD_Output              ,ONLY: Visualize,PrintStatusLine
USE MOD_HDF5_Output         ,ONLY: WriteState,WriteBaseFlow
USE MOD_Mesh_Vars           ,ONLY: MeshFile,nGlobalElems
USE MOD_DG                  ,ONLY: DGTimeDerivative_weakForm
USE MOD_DG_Vars             ,ONLY: U
USE MOD_Overintegration     ,ONLY: Overintegration
USE MOD_Overintegration_Vars,ONLY: OverintegrationType
USE MOD_ApplyJacobianCons   ,ONLY: ApplyJacobianCons
USE MOD_RecordPoints        ,ONLY: RecordPoints,WriteRP
USE MOD_RecordPoints_Vars   ,ONLY: RP_onProc
USE MOD_Sponge_Vars         ,ONLY: CalcPruettDamping
USE MOD_Indicator           ,ONLY: doCalcIndicator,CalcIndicator
#if FV_ENABLED
USE MOD_FV
#endif
use MOD_IO_HDF5
! Particle variables
USE MOD_Part_Emission,         ONLY: AdaptiveBCAnalyze
USE MOD_Particle_Analyze,      ONLY: AnalyzeParticles
USE MOD_Particle_Boundary_Vars,ONLY: nAdaptiveBC
USE MOD_Particle_Mesh,         ONLY: CountPartsPerElem
USE MOD_Particle_Mesh_Vars
USE MOD_Particle_MPI,          ONLY: IRecvNbOfParticles, MPIParticleSend,MPIParticleRecv,SendNbOfparticles
USE MOD_Particle_Output,       ONLY: Visualize_Particles
USE MOD_Particle_Tracking_vars
USE MOD_Particle_Vars
USE MOD_ReadInTools
USE MOD_HDF5_output,           ONLY: WriteIMDStateToHDF5
IMPLICIT NONE
!-----------------------------------------------------------------------------------------------------------------------------------
! INPUT VARIABLES
!-----------------------------------------------------------------------------------------------------------------------------------
! LOCAL VARIABLES
INTEGER                      :: iPart
LOGICAL                      :: NoPartInside
INTEGER                      :: nLostPartsTot
!===================================================================================================================================

IF (iter.LE.MaximumIterNum) THEN
    dt_max_particles = dt ! initial evolution of field with maxwellts
ELSE
  NoPartInside=.TRUE.
  DO 
    vMaxx = 0.
    vMaxy = 0.
    vMaxz = 0.
    DO iPart=1,PDM%ParticleVecLength
      IF (PDM%ParticleInside(iPart)) THEN
        vMaxx = MAX( vMaxx , ABS(PartState(iPart, 4) + dt_temp*Pt(iPart,1)) )
        vMaxy = MAX( vMaxy , ABS(PartState(iPart, 5) + dt_temp*Pt(iPart,2)) )
        vMaxz = MAX( vMaxz , ABS(PartState(iPart, 6) + dt_temp*Pt(iPart,3)) )
        NoPartInside=.FALSE. 
      END IF
    END DO
vMax = MAX(vMaxx,vMaxy,vMaxz,1.0) 

#ifdef MPI
    CALL MPI_ALLREDUCE(MPI_IN_PLACE,vMax,1,MPI_DOUBLE_PRECISION,MPI_MAX,MPI_COMM_WORLD,iError)
    CALL MPI_ALLREDUCE(MPI_IN_PLACE,NoPartInside,1,MPI_LOGICAL,MPI_LAND,MPI_COMM_WORLD,iError)
#endif /*MPI*/
    IF (NoPartInside) THEN
      dt_max_particles = dt
      EXIT
    ELSE
      dt_max_particles =  max(dt_part_ratio*dt*c/(vMax),dt)
    END IF
    dt_temp = (dt_max_particles+dt_temp)/2
    IF((dt_temp.GE.dt_max_particles*0.95).AND.(dt_temp.LE.dt_max_particles*1.05)) EXIT
  END DO
END IF

dt_Min = dt_max_particles
IterDisplayStep = MAX(INT(IterDisplayStepUser/(dt_max_particles / dt)),1) !IterDisplayStepUser refers to dt

IF(enableParticleMerge) THEN
  IF ((iter.GT.0).AND.(MOD(iter,vMPFMergeParticleIter).EQ.0)) doParticleMerge=.true.
END IF

! sampling of near adaptive boundary element values
!IF(nAdaptiveBC.GT.0) CALL AdaptiveBCAnalyze()

IF(CountNbOfLostParts)THEN
#ifdef MPI
    IF(MPIRoot) THEN
      CALL MPI_REDUCE(nLostParts,nLostPartsTot,1,MPI_INTEGER,MPI_SUM,0,MPI_COMM_WORLD,IERROR)
    ELSE ! no Root
      CALL MPI_REDUCE(nLostParts,nLostPartsTot,1,MPI_INTEGER,MPI_SUM,0,MPI_COMM_WORLD,IERROR)
    END IF
#else
    nLostPartsTot=nLostParts
#endif /*MPI*/
END IF

IF(CountNbOfLostParts)THEN
    WRITE(UNIT_stdOut,'(A,I12)')' NbOfLostParticle : ',nLostPartsTot
END IF

IF(DoWriteStateToHDF5)THEN
#if (PP_TimeDiscMethod!=1) || (PP_TimeDiscMethod!=2) || (PP_TimeDiscMethod!=6)
        CALL CountPartsPerElem()
#endif
        CALL WriteStateToHDF5(TRIM(MeshFile),time,tFuture)
END IF

END SUBROUTINE Particle_TimeDisc

!===================================================================================================================================
!> Low-Storage Runge-Kutta integration: 2 register version
!> This procedure takes the current time t, the time step dt and the solution at
!> the current time U(t) and returns the solution at the next time level.
!> RKA/b/c coefficients are low-storage coefficients, NOT the ones from butcher table.
!===================================================================================================================================
SUBROUTINE Particle_TimeStepByLSERK()
! MODULES
USE MOD_PreProc
USE MOD_Vector
USE MOD_DG,                      ONLY: DGTimeDerivative_weakForm
USE MOD_DG_Vars,                 ONLY: U,Ut,nTotalU
USE MOD_TimeDisc_Vars,           ONLY: dt,RKA,RKb,RKc,nRKStages,CurrentStage
USE MOD_Mesh_Vars,               ONLY: nElems
USE MOD_PruettDamping,           ONLY: TempFilterTimeDeriv
USE MOD_Sponge_Vars,             ONLY: CalcPruettDamping
USE MOD_Indicator,               ONLY: doCalcIndicator,CalcIndicator
#if FV_ENABLED
USE MOD_FV,                      ONLY: FV_Switch
USE MOD_FV_Vars,                 ONLY: FV_toDGinRK
#endif
#ifdef MPI
USE MOD_Particle_MPI_Vars,       ONLY: DoExternalParts
USE MOD_Particle_Mesh,           ONLY: CountPartsPerElem
USE MOD_Particle_MPI,            ONLY: IRecvNbOfParticles, MPIParticleSend,MPIParticleRecv,SendNbOfparticles
USE MOD_Particle_MPI_Vars,       ONLY: PartMPIExchange
USE MOD_Particle_MPI_Vars,       ONLY: ExtPartState,ExtPartSpecies,ExtPartMPF,ExtPartToFIBGM
#endif /*MPI*/
USE MOD_part_emission,           ONLY: ParticleInserting
USE MOD_part_MPFtools,           ONLY: StartParticleMerge
USE MOD_part_RHS,                ONLY: CalcPartRHS
USE MOD_part_tools,              ONLY: UpdateNextFreePosition
USE MOD_Particle_Analyze_Vars,   ONLY: DoVerifyCharge
USE MOD_Particle_Tracking,       ONLY: ParticleTracing,ParticleRefTracking
USE MOD_Particle_Tracking_vars,  ONLY: tTracking,tLocalization,DoRefMapping,MeasureTrackTime
USE MOD_Particle_Vars,           ONLY: PartState, Pt, Pt_temp, LastPartPos, DelayTime, PEM, PDM, & 
! IMPLICIT VARIABLE HANDLING
IMPLICIT NONE
!-----------------------------------------------------------------------------------------------------------------------------------
! INPUT VARIABLES
REAL,INTENT(IN)               :: tendDiff
REAL,INTENT(INOUT)            :: t
INTEGER(KIND=8),INTENT(INOUT) :: iter
!-----------------------------------------------------------------------------------------------------------------------------------
! LOCAL VARIABLES
REAL                          :: timeStart,timeEnd
!===================================================================================================================================
#ifdef MPI
CALL CountPartsPerElem()
#endif /*MPI*/

IF ((t.GE.DelayTime).OR.(iter.EQ.0)) THEN
  ! communicate shape function particles
#ifdef MPI
  PartMPIExchange%nMPIParticles=0
  IF(DoExternalParts)THEN
    ! as we do not have the shape function here, we have to deallocate something
    SDEALLOCATE(ExtPartState)
    SDEALLOCATE(ExtPartSpecies)
    SDEALLOCATE(ExtPartToFIBGM)
    SDEALLOCATE(ExtPartMPF)
    ! open receive buffer for number of particles
    CALL IRecvNbofParticles()
    ! send number of particles
    CALL SendNbOfParticles()
  END IF
#endif /*MPI*/
END IF

IF (t.GE.DelayTime) THEN
  ! forces on particle
  ! can be used to hide sending of number of particles
  CALL InterpolateFieldToParticle(doInnerParts=.TRUE.)
  CALL CalcPartRHS()
END IF

IF ((t.GE.DelayTime).OR.(iter.EQ.0)) THEN
  ! communicate shape function particles
#ifdef MPI
  PartMPIExchange%nMPIParticles=0
  IF(DoExternalParts)THEN
    ! finish communication of number of particles and send particles
    CALL MPIParticleSend()
  END IF 
#endif /*MPI*/
  ! because of emmision and UpdateParticlePosition
  CALL Deposition(doInnerParts=.TRUE.)
#ifdef MPI
  IF(DoExternalParts)THEN
    ! finish communication
    CALL MPIParticleRecv()
  END IF
  ! here: finish deposition with delta kernal
  !       maps source terms in physical space
  ! ALWAYS require
  PartMPIExchange%nMPIParticles=0
#endif /*MPI*/
  CALL Deposition(doInnerParts=.FALSE.)
  IF(DoVerifyCharge) CALL VerifyDepositedCharge()
END IF

! particles
LastPartPos(1:PDM%ParticleVecLength,1)=PartState(1:PDM%ParticleVecLength,1)
LastPartPos(1:PDM%ParticleVecLength,2)=PartState(1:PDM%ParticleVecLength,2)
LastPartPos(1:PDM%ParticleVecLength,3)=PartState(1:PDM%ParticleVecLength,3)
PEM%lastElement(1:PDM%ParticleVecLength)=PEM%Element(1:PDM%ParticleVecLength)
IF (t.GE.DelayTime) THEN
  Pt_temp(1:PDM%ParticleVecLength,1) = PartState(1:PDM%ParticleVecLength,4) 
  Pt_temp(1:PDM%ParticleVecLength,2) = PartState(1:PDM%ParticleVecLength,5) 
  Pt_temp(1:PDM%ParticleVecLength,3) = PartState(1:PDM%ParticleVecLength,6) 
  Pt_temp(1:PDM%ParticleVecLength,4) = Pt(1:PDM%ParticleVecLength,1) 
  Pt_temp(1:PDM%ParticleVecLength,5) = Pt(1:PDM%ParticleVecLength,2) 
  Pt_temp(1:PDM%ParticleVecLength,6) = Pt(1:PDM%ParticleVecLength,3)
  PartState(1:PDM%ParticleVecLength,1) = PartState(1:PDM%ParticleVecLength,1) &
                                       + PartState(1:PDM%ParticleVecLength,4)*b_dt(1)
  PartState(1:PDM%ParticleVecLength,2) = PartState(1:PDM%ParticleVecLength,2) &
                                       + PartState(1:PDM%ParticleVecLength,5)*b_dt(1)
  PartState(1:PDM%ParticleVecLength,3) = PartState(1:PDM%ParticleVecLength,3) &
                                       + PartState(1:PDM%ParticleVecLength,6)*b_dt(1)
  PartState(1:PDM%ParticleVecLength,4) = PartState(1:PDM%ParticleVecLength,4) &
                                       + Pt(1:PDM%ParticleVecLength,1)*b_dt(1)
  PartState(1:PDM%ParticleVecLength,5) = PartState(1:PDM%ParticleVecLength,5) &
                                       + Pt(1:PDM%ParticleVecLength,2)*b_dt(1)
  PartState(1:PDM%ParticleVecLength,6) = PartState(1:PDM%ParticleVecLength,6) &
                                       + Pt(1:PDM%ParticleVecLength,3)*b_dt(1)
END IF

#ifdef MPI
  CALL SendNbOfParticles()
#endif /*MPI*/
  
END SUBROUTINE Particle_TimeStepByLSERK


SUBROUTINE Particle_TimeStepByLSERK_RK(t)
! MODULES
USE MOD_PreProc
USE MOD_Vector
USE MOD_DG,                      ONLY: DGTimeDerivative_weakForm
USE MOD_DG_Vars,                 ONLY: U,Ut,nTotalU
USE MOD_TimeDisc_Vars,           ONLY: dt,RKA,RKb,RKc,nRKStages,CurrentStage
USE MOD_Mesh_Vars,               ONLY: nElems
USE MOD_PruettDamping,           ONLY: TempFilterTimeDeriv
USE MOD_Sponge_Vars,             ONLY: CalcPruettDamping
USE MOD_Indicator,               ONLY: doCalcIndicator,CalcIndicator
#if FV_ENABLED
USE MOD_FV,                      ONLY: FV_Switch
USE MOD_FV_Vars,                 ONLY: FV_toDGinRK
#endif
#ifdef MPI
USE MOD_Particle_MPI_Vars,       ONLY: DoExternalParts
USE MOD_Particle_Mesh,           ONLY: CountPartsPerElem
USE MOD_Particle_MPI,            ONLY: IRecvNbOfParticles, MPIParticleSend,MPIParticleRecv,SendNbOfparticles
USE MOD_Particle_MPI_Vars,       ONLY: PartMPIExchange
USE MOD_Particle_MPI_Vars,       ONLY: ExtPartState,ExtPartSpecies,ExtPartMPF,ExtPartToFIBGM
#endif /*MPI*/
USE MOD_part_emission,           ONLY: ParticleInserting
USE MOD_part_MPFtools,           ONLY: StartParticleMerge
USE MOD_part_RHS,                ONLY: CalcPartRHS
USE MOD_part_tools,              ONLY: UpdateNextFreePosition
USE MOD_Particle_Analyze_Vars,   ONLY: DoVerifyCharge
USE MOD_Particle_Tracking,       ONLY: ParticleTracing,ParticleRefTracking
USE MOD_Particle_Tracking_vars,  ONLY: tTracking,tLocalization,DoRefMapping,MeasureTrackTime
USE MOD_Particle_Vars,           ONLY: PartState, Pt, Pt_temp, LastPartPos, DelayTime, PEM, PDM, & 
! IMPLICIT VARIABLE HANDLING
IMPLICIT NONE
!-----------------------------------------------------------------------------------------------------------------------------------
! INPUT VARIABLES
REAL,INTENT(IN)               :: tendDiff
REAL,INTENT(INOUT)            :: t
INTEGER(KIND=8),INTENT(INOUT) :: iter
!-----------------------------------------------------------------------------------------------------------------------------------
! LOCAL VARIABLES
REAL                          :: timeStart,timeEnd
!===================================================================================================================================
IF (t.GE.DelayTime) THEN 
#ifdef MPI
     tLBStart = LOCALTIME() ! LB Time Start
#endif /*MPI*/
     CALL InterpolateFieldToParticle(doInnerParts=.TRUE.)
#ifdef MPI
     CALL MPIParticleSend()
#endif /*MPI*/
!    ! deposition  
     CALL Deposition(doInnerParts=.TRUE.)
#ifdef MPI
     CALL MPIParticleRecv()
#endif /*MPI*/
     CALL InterpolateFieldToParticle(doInnerParts=.FALSE.)
     CALL CalcPartRHS()

     CALL Deposition(doInnerParts=.FALSE.)
     IF(DoVerifyCharge) CALL VerifyDepositedCharge()
        #ifdef MPI
             PartMPIExchange%nMPIParticles=0
        #endif /*MPI*/
     END IF    
    #ifdef MPI
      CALL CountPartsPerElem()
    #endif /*MPI*/

  ! field solver
    #endif /*MPI*/
      IF(DoPML) THEN
        CALL CalcPMLSource()
        CALL PMLTimeDerivative()
      END IF
      
  ! particle step
  IF (t.GE.DelayTime) THEN
    LastPartPos(1:PDM%ParticleVecLength,1)=PartState(1:PDM%ParticleVecLength,1)
    LastPartPos(1:PDM%ParticleVecLength,2)=PartState(1:PDM%ParticleVecLength,2)
    LastPartPos(1:PDM%ParticleVecLength,3)=PartState(1:PDM%ParticleVecLength,3)
    PEM%lastElement(1:PDM%ParticleVecLength)=PEM%Element(1:PDM%ParticleVecLength)
    Pt_temp(1:PDM%ParticleVecLength,1) = PartState(1:PDM%ParticleVecLength,4) &
                             - RK_a(iStage) * Pt_temp(1:PDM%ParticleVecLength,1)
    Pt_temp(1:PDM%ParticleVecLength,2) = PartState(1:PDM%ParticleVecLength,5) &
                             - RK_a(iStage) * Pt_temp(1:PDM%ParticleVecLength,2)
    Pt_temp(1:PDM%ParticleVecLength,3) = PartState(1:PDM%ParticleVecLength,6) &
                             - RK_a(iStage) * Pt_temp(1:PDM%ParticleVecLength,3)
    Pt_temp(1:PDM%ParticleVecLength,4) = Pt(1:PDM%ParticleVecLength,1) &
                             - RK_a(iStage) * Pt_temp(1:PDM%ParticleVecLength,4)
    Pt_temp(1:PDM%ParticleVecLength,5) = Pt(1:PDM%ParticleVecLength,2) &
                             - RK_a(iStage) * Pt_temp(1:PDM%ParticleVecLength,5)
    Pt_temp(1:PDM%ParticleVecLength,6) = Pt(1:PDM%ParticleVecLength,3) &
                             - RK_a(iStage) * Pt_temp(1:PDM%ParticleVecLength,6)
    PartState(1:PDM%ParticleVecLength,1) = PartState(1:PDM%ParticleVecLength,1) &
                                       + Pt_temp(1:PDM%ParticleVecLength,1)*b_dt(iStage)
    PartState(1:PDM%ParticleVecLength,2) = PartState(1:PDM%ParticleVecLength,2) &
                                       + Pt_temp(1:PDM%ParticleVecLength,2)*b_dt(iStage)
    PartState(1:PDM%ParticleVecLength,3) = PartState(1:PDM%ParticleVecLength,3) &
                                       + Pt_temp(1:PDM%ParticleVecLength,3)*b_dt(iStage)
    PartState(1:PDM%ParticleVecLength,4) = PartState(1:PDM%ParticleVecLength,4) &
                                       + Pt_temp(1:PDM%ParticleVecLength,4)*b_dt(iStage)
    PartState(1:PDM%ParticleVecLength,5) = PartState(1:PDM%ParticleVecLength,5) &
                                       + Pt_temp(1:PDM%ParticleVecLength,5)*b_dt(iStage)
    PartState(1:PDM%ParticleVecLength,6) = PartState(1:PDM%ParticleVecLength,6) &
                                       + Pt_temp(1:PDM%ParticleVecLength,6)*b_dt(iStage)
#ifdef MPI
    ! particle tracking
    CALL IRecvNbofParticles()
#endif /*MPI*/
    IF(DoRefMapping)THEN
      CALL ParticleRefTracking()
    ELSE
      CALL ParticleTracing()
    END IF
#ifdef MPI
    CALL SendNbOfParticles()
#endif /*MPI*/
END IF

IF (t.GE.DelayTime) THEN
#ifdef MPI
  CALL MPIParticleSend()
  CALL MPIParticleRecv()
  PartMPIExchange%nMPIParticles=0
#endif /*MPI*/
END IF 

IF (doParticleMerge) THEN
    ALLOCATE(PEM%pStart(1:PP_nElems)           , &
             PEM%pNumber(1:PP_nElems)          , &
             PEM%pNext(1:PDM%maxParticleNumber), &
             PEM%pEnd(1:PP_nElems) )
END IF

IF ((t.GE.DelayTime).OR.(t.EQ.0)) THEN
  CALL UpdateNextFreePosition()
END IF

IF (doParticleMerge) THEN
  CALL StartParticleMerge()  
    DEALLOCATE(PEM%pStart , &
               PEM%pNumber, &
               PEM%pNext  , &
               PEM%pEnd   )
  END IF
  
  CALL UpdateNextFreePosition()
END IF

END SUBROUTINE Particle_TimeStepByLSERK_RK

END MODULE MOD_Particle_TimeDisc
